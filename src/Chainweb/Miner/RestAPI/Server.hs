{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

-- |
-- Module: Chainweb.Miner.RestAPI.Server
-- Copyright: Copyright Â© 2018 - 2020 Kadena LLC.
-- License: MIT
-- Maintainer: Colin Woodbury <colin@kadena.io>
-- Stability: experimental
--
--
module Chainweb.Miner.RestAPI.Server
( miningServer
, someMiningServer
) where

import Chainweb.Cut.Create
import Chainweb.Logger
import Chainweb.Miner.Config
import Chainweb.Miner.Coordinator
import Chainweb.Miner.Core
import Chainweb.Miner.RestAPI (MiningApi)
import Chainweb.RestAPI.Utils
import Chainweb.Utils
import Chainweb.Utils.Serialization
import Chainweb.Version

import Control.Concurrent.STM.TVar
import Control.Lens
import Control.Monad
import Control.Monad.Catch (try, catches)
import Control.Monad.Catch qualified as E
import Control.Monad.Except (throwError)
import Control.Monad.IO.Class (liftIO)
import Control.Monad.STM

import Data.Binary.Builder (fromByteString)
import Data.Proxy (Proxy(..))

import Network.Wai.EventSource (ServerEvent(..), eventSourceAppIO)

import Servant.API
import Servant.Server

import System.LogLevel
import System.Random

-- -------------------------------------------------------------------------- --
-- Work Handler

workHandler
    :: Logger l
    => MiningCoordination l
    -> Handler WorkBytes
workHandler mr = do
    wh <- liftIO $ work mr
    return $ WorkBytes $ runPutS $ encodeWorkHeader wh

-- -------------------------------------------------------------------------- --
-- Solved Handler

solvedHandler
    :: forall l
    . Logger l
    => MiningCoordination l
    -> HeaderBytes
    -> Handler NoContent
solvedHandler mr (HeaderBytes bytes) = do
    liftIO (try $ runGetS decodeSolvedWork bytes) >>= \case
        Left (DecodeException e) ->
            throwError $ setErrText ("Decoding error: " <> e) err400
        Left _ ->
            throwError $ setErrText "Unexpected encoding exception" err400
        Right solved -> do
            result <- liftIO $ catches (Right () <$ solve mr solved)
                [ E.Handler $ \NoAsscociatedPayload ->
                    return $ Left $ setErrText "No associated Payload" err404
                , E.Handler $ \(InvalidSolvedHeader _ msg) ->
                    return $ Left $ setErrText ("Invalid solved work: " <> msg) err400
                ]
            case result of
                Left e -> throwError e
                Right () -> return NoContent

-- -------------------------------------------------------------------------- --
--  Updates Handler

-- | Whether the work is outdated and should be thrown out immediately,
-- or there's just fresher work available and the old work is still valid.
--
-- NOTE: this does not provide any information about whether the chain is ready
-- or not.
--
-- FIXME:
--
-- Exposing this information to mining clients is problematic. It assumes that
-- clients are able to pick an optimal mining strategy (which should represent a
-- Nash equilibrium). For instance, if clients request new work each time any
-- event is received for a chain, Clients will spent less time mining chains
-- that receive many 'WorkRefreshed' events, because on each event a new chain
-- is selected uniformily. The currently used difficulty adjustement algorithm
-- assumes that all chains receive and equal amount of hash power. Hence, the
-- system will converge towards a state where chains that receive more hash
-- power are being blocked more often and miners are more likely the race on
-- chains that receive less hash power. As a consequence the number of orphans
-- is going to increase.
--
-- While it is desirable to provide sufficient information to allow smart and
-- educated miners to pick their own chain selection strategy, the API should
-- ensure that uninformed miners are going to use a reasonable default strategy
-- that distributes hash power uniformily accross all chains.
--
-- Unlike WorkOutdated events, the distribution of WorkRefreshed events is not
-- generated by the randomized mining process. Instead WorkRefreshed depends on
-- the rate at which transactions are sent to the mempool for the respective
-- chain. Beside of introducing random byzantine skew in the hash power
-- distribution and increasing orphan block counts, this condition can also be
-- exploited explicitely by a malicious actor.
--
-- (Note that uniform distribution of hash power accross all chains is not the
-- optimal strategy in a collaborative model. In a collaborative model miners
-- could reduce the numbers of orphans be giving a slight preference to chains
-- with a lower block height in the current cut. However, to the best of our
-- knowledge that strategy does not represent an equilibrium in an adversarial
-- model. Uniform distribution is the best strategy that we are aware of for an
-- adversariable setting.)
--
data WorkChange
    = WorkOutdated
        -- ^ The current work for the chain is invalid.
        --
        -- The mining client should request new work. If the chain is currently
        -- blocked it will be excluded in the selection of the new work.
        --
    | WorkRefreshed
        -- ^ The current work for the chain is still valid, but newer work is
        -- available.
        --
    deriving stock (Show, Eq)

-- | This event triggers when the previous work got outdated
--
awaitWorkChange
    :: MiningState
    -> ChainId
    -> TVar Bool
        -- ^ Timer
    -> TVar WorkState
        -- ^ Previous Work State
    -> IO (Maybe WorkChange)
awaitWorkChange ms cid timer prevVar = go
  where
    go = do
        -- await a change in the work state of the chain
        r <- atomically $ readTVar timer >>= \case
            True -> return Nothing
            False -> do
                prev <- readTVar prevVar
                cur <- readTVar (ms ^?! ixg cid)
                -- TODO: this guard is potentially somewhat expense. However,
                -- ideally in most cases it should be possible to establish
                -- equality by pointer equality.
                guard (prev /= cur)
                writeTVar prevVar cur
                return $ Just (prev, cur)

        -- check result
        case r of
            Nothing -> return Nothing
            Just (WorkReady prh ppld pps pwh, WorkReady crh cpld cps cwh)
                | prh /= crh -> return $ Just WorkOutdated
                | pps /= cps -> return $ Just WorkOutdated
                | ppld /= cpld -> return $ Just WorkRefreshed
                | pwh /= cwh -> return $ Just WorkRefreshed
                | otherwise -> go
            Just (WorkReady{}, _) -> return $ Just WorkOutdated
            _ -> go

-- |
--
-- FIXME: the that current API design is broken in several ways. The main issues
-- are:
--
-- 1.  Lack of synchronization between the updates stream and the GET work API.
--     Events from the update stream race against work returned by GET work.
-- 2.  It does not support mining clients in deploying a stable and optimal
--     mining strategy. Any use of the WorkRefreshed event requires non-trivial
--     client side logic to guarantee a uniform distribution of hash power
--     across chains.
--     A simple strategy for clients could be to ignore the WorkRefreshed events
--     and instead request new work at a fixed rate.
--
-- FIXME: consider sending the WorkRefreshed Event at a fixed rate on each
-- chain.
--
-- FIXME: update openAPI spec for mining API to reflect the "Refreshed Block"
-- event.
--
updatesHandler
    :: Logger l
    => MiningCoordination l
    -> ChainBytes
    -> Tagged Handler Application
updatesHandler mr (ChainBytes cbytes) = Tagged $ \req resp -> do
    cid <- runGetS decodeChainId cbytes

    -- An update stream is closed after @timeout@ seconds. We add some jitter to
    -- availablility of streams is uniformily distributed over time and not
    -- predictable.
    --
    jitter <- randomRIO @Double (0.9, 1.1)
    timer <- registerDelay (round $ jitter * realToFrac timeout * 1_000_000)

    curWork <- readTVarIO (_coordState mr ^?! ixg cid)
    prevVar <- newTVarIO curWork

    eventSourceAppIO (go timer cid prevVar) req resp
  where
    timeout = _coordinationUpdateStreamTimeout $ _coordConf mr

    go :: TVar Bool -> ChainId -> TVar WorkState -> IO ServerEvent
    go timer cid prevVar = do
        awaitWorkChange (_coordState mr) cid timer prevVar >>= \case
            Nothing -> do
                logFunctionText logger Debug $
                    "sent close event to miner on chain " <> toText cid
                return CloseEvent
            Just WorkOutdated -> do
                logFunctionText logger Debug $
                    "sent work outdated event to miner on chain " <> toText cid
                return $ ServerEvent (Just $ fromByteString "New Cut") Nothing []
            Just WorkRefreshed -> do
                logFunctionText logger Debug $
                    "sent work outdated event to miner on chain " <> toText cid
                return $ ServerEvent (Just $ fromByteString "Refreshed Block") Nothing []
        where
        logger = addLabel ("chain", toText cid) (_coordLogger mr)

-- -------------------------------------------------------------------------- --
-- Mining API Server

miningServer
    :: forall l (v :: ChainwebVersionT)
    .  Logger l
    => MiningCoordination l
    -> Server (MiningApi v)
miningServer mr = workHandler mr :<|> solvedHandler mr :<|> updatesHandler mr

someMiningServer :: Logger l => ChainwebVersion -> MiningCoordination l -> SomeServer
someMiningServer (FromSingChainwebVersion (SChainwebVersion :: Sing vT)) mr =
    SomeServer (Proxy @(MiningApi vT)) $ miningServer mr
