{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

-- |
-- Module: Chainweb.Miner.RestAPI.Server
-- Copyright: Copyright Â© 2018 - 2020 Kadena LLC.
-- License: MIT
-- Maintainer: Colin Woodbury <colin@kadena.io>
-- Stability: experimental
--
--
module Chainweb.Miner.RestAPI.Server
( miningServer
, someMiningServer
) where

import Chainweb.Cut.Create
import Chainweb.Logger
import Chainweb.Miner.Config
import Chainweb.Miner.Coordinator
import Chainweb.Miner.Core
import Chainweb.Miner.PayloadCache
import Chainweb.Miner.RestAPI (MiningApi)
import Chainweb.PayloadProvider
import Chainweb.RestAPI.Utils
import Chainweb.Utils
import Chainweb.Utils.Serialization
import Chainweb.Version

import Control.Concurrent.STM.TVar
import Control.Lens
import Control.Monad
import Control.Monad.Catch (try, catches)
import Control.Monad.Catch qualified as E
import Control.Monad.Except (throwError)
import Control.Monad.IO.Class (liftIO)
import Control.Monad.STM

import Data.Binary.Builder qualified as BB (fromByteString)
import Data.Proxy (Proxy(..))

import Network.Wai.EventSource (ServerEvent(..), eventSourceAppIO)

import Servant.API
import Servant.Server

import System.LogLevel
import System.Random

-- -------------------------------------------------------------------------- --
-- Work Handler

workHandler
    :: Logger l
    => HasVersion
    => MiningCoordination l
    -> Handler WorkBytes
workHandler mr = do
    wh <- liftIO $ work mr
    return $ WorkBytes $ runPutS $ encodeMiningWork wh

-- -------------------------------------------------------------------------- --
-- Solved Handler

solvedHandler
    :: forall l
    . Logger l
    => HasVersion
    => MiningCoordination l
    -> HeaderBytes
    -> Handler NoContent
solvedHandler mr (HeaderBytes bytes) = do
    liftIO (try $ runGetS decodeSolvedWork bytes) >>= \case
        Left (DecodeException e) ->
            throwError $ setErrText ("Decoding error: " <> e) err400
        Left _ ->
            throwError $ setErrText "Unexpected encoding exception" err400
        Right solved -> do
            result <- liftIO $ catches (Right () <$ solve mr solved)
                [ E.Handler $ \NoAsscociatedPayload ->
                    return $ Left $ setErrText "No associated Payload" err404
                , E.Handler $ \(InvalidSolvedHeader msg) ->
                    return $ Left $ setErrText ("Invalid solved work: " <> msg) err400
                ]
            case result of
                Left e -> throwError e
                Right () -> return NoContent

-- -------------------------------------------------------------------------- --
--  Updates Handler

-- | Whether the work is outdated and should be thrown out immediately,
-- or there's just fresher work available and the old work is still valid.
--
-- NOTE: this does not provide any information about whether the chain is ready
-- or not.
--
-- FIXME:
--
-- Exposing this information to mining clients is problematic. It assumes that
-- clients are able to pick an optimal mining strategy (which should represent a
-- Nash equilibrium). For instance, if clients request new work each time any
-- event is received for a chain, Clients will spent less time mining chains
-- that receive many 'WorkRefreshed' events, because on each event a new chain
-- is selected uniformily. The currently used difficulty adjustement algorithm
-- assumes that all chains receive and equal amount of hash power. Hence, the
-- system will converge towards a state where chains that receive more hash
-- power are being blocked more often and miners are more likely the race on
-- chains that receive less hash power. As a consequence the number of orphans
-- is going to increase.
--
-- While it is desirable to provide sufficient information to allow smart and
-- educated miners to pick their own chain selection strategy, the API should
-- ensure that uninformed miners are going to use a reasonable default strategy
-- that distributes hash power uniformily accross all chains.
--
-- Unlike WorkOutdated events, the distribution of WorkRefreshed events is not
-- generated by the randomized mining process. Instead WorkRefreshed depends on
-- the rate at which transactions are sent to the mempool for the respective
-- chain. Beside of introducing random byzantine skew in the hash power
-- distribution and increasing orphan block counts, this condition can also be
-- exploited explicitely by a malicious actor.
--
-- (Note that uniform distribution of hash power accross all chains is not the
-- optimal strategy in a collaborative model. In a collaborative model miners
-- could reduce the numbers of orphans be giving a slight preference to chains
-- with a lower block height in the current cut. However, to the best of our
-- knowledge that strategy does not represent an equilibrium in an adversarial
-- model. Uniform distribution is the best strategy that we are aware of for an
-- adversariable setting.)
--
data WorkChange
    = WorkOutdated
        -- ^ The current work for the chain is invalid.
        --
        -- The mining client should request new work. If the chain is currently
        -- blocked it will be excluded in the selection of the new work.
        --
    | WorkRefreshed
        -- ^ The current work for the chain is still valid, but newer work is
        -- available.
        --
    deriving stock (Show, Eq)

-- | This event triggers when the previous work got outdated
--
awaitWorkChange
    :: TVar (Maybe ParentState)
    -> PayloadCache
    -> TVar Bool
        -- ^ Timer
    -> TVar (Maybe ParentState, Maybe NewPayload)
    -> IO (Maybe WorkChange)
awaitWorkChange var payloadCache timer prevVar = go
  where
    go = do
        -- await a change in the work state of the chain
        atomically $ readTVar timer >>= \case
            True -> return Nothing
            False -> do
                prev <- readTVar prevVar
                cur <- readTVar var
                (workChange, curPayload) <- case (prev, cur) of
                    ((Just _, _), Nothing) ->
                        -- the parent state has been vacated;
                        -- there are no longer parents to mine on,
                        -- so stop mining
                        return (WorkOutdated, Nothing)
                    ((Nothing, _), Just _) ->
                        -- the parent state has been populated;
                        -- there are now parents to mine on,
                        -- so start mining
                        return (WorkOutdated, Nothing)
                    ((Nothing, _), Nothing) ->
                        -- the parent state is still empty
                        retry
                    ((oldMaybeParentState, oldMaybePayload), Just newParentState) -> do
                        case (oldMaybeParentState, oldMaybePayload) of
                            (Just oldParentState, oldPayload)
                                | oldParentState == newParentState -> do
                                    -- the parent state remains the same,
                                    -- so we await a refreshed payload
                                    newPayload <- awaitLatestPayloadForParentStateSTM payloadCache newParentState
                                    guard (Just newPayload /= oldPayload)
                                    return (WorkRefreshed, Just newPayload)
                                | otherwise ->
                                    return (WorkOutdated, Nothing)
                writeTVar prevVar (cur, curPayload)

                return $ Just workChange

-- |
--
-- FIXME: the that current API design is broken in several ways. The main issues
-- are:
--
-- 1.  Lack of synchronization between the updates stream and the GET work API.
--     Events from the update stream race against work returned by GET work.
-- 2.  It does not support mining clients in deploying a stable and optimal
--     mining strategy. Any use of the WorkRefreshed event requires non-trivial
--     client side logic to guarantee a uniform distribution of hash power
--     across chains.
--     A simple strategy for clients could be to ignore the WorkRefreshed events
--     and instead request new work at a fixed rate.
--
-- FIXME: consider sending the WorkRefreshed Event at a fixed rate on each
-- chain.
--
-- FIXME: update openAPI spec for mining API to reflect the "Refreshed Block"
-- event.
--
updatesHandler
    :: Logger l
    => HasVersion
    => MiningCoordination l
    -> ChainBytes
    -> Tagged Handler Application
updatesHandler mr (ChainBytes cbytes) = Tagged $ \req resp -> do
    cid <- runGetS decodeChainId cbytes

    -- An update stream is closed after @timeout@ seconds. We add some jitter to
    -- availablility of streams is uniformily distributed over time and not
    -- predictable.
    --
    jitter <- randomRIO @Double (0.9, 1.1)
    timer <- registerDelay (round $ jitter * realToFrac timeout * 1_000_000)

    curWork <- atomically $ readTVar (_coordParentState mr ^?! ixg cid) >>= \case
        Nothing -> return (Nothing, Nothing)
        Just parentState -> do
            pload <- awaitLatestPayloadForParentStateSTM (_coordPayloadCache mr ^?! ixg cid) parentState
            return (Just parentState, Just pload)

    prevVar <- newTVarIO curWork

    eventSourceAppIO (go timer cid prevVar) req resp
  where
    timeout = _coordinationUpdateStreamTimeout $ _coordConf mr

    go :: TVar Bool -> ChainId -> TVar (Maybe ParentState, Maybe NewPayload) -> IO ServerEvent
    go timer cid prevVar = do
        awaitWorkChange (_coordParentState mr ^?! ixg cid) (_coordPayloadCache mr ^?! ixg cid) timer prevVar >>= \case
            Nothing -> do
                logFunctionText logger Debug $
                    "sent close event to miner on chain " <> toText cid
                return CloseEvent
            Just WorkOutdated -> do
                logFunctionText logger Debug $
                    "sent work outdated event to miner on chain " <> toText cid
                return $ ServerEvent (Just $ BB.fromByteString "New Cut") Nothing []
            Just WorkRefreshed -> do
                logFunctionText logger Debug $
                    "sent work outdated event to miner on chain " <> toText cid
                return $ ServerEvent (Just $ BB.fromByteString "Refreshed Block") Nothing []
        where
        logger = addLabel ("chain", toText cid) (_coordLogger mr)

-- -------------------------------------------------------------------------- --
-- Mining API Server

miningServer
    :: forall l (v :: ChainwebVersionT)
    .  Logger l
    => HasVersion
    => MiningCoordination l
    -> Server (MiningApi v)
miningServer mr = workHandler mr :<|> solvedHandler mr :<|> updatesHandler mr

someMiningServer :: Logger l => HasVersion => MiningCoordination l -> SomeServer
someMiningServer mr = case implicitVersion of
    FromSingChainwebVersion (SChainwebVersion :: Sing vT) ->
        SomeServer (Proxy @(MiningApi vT)) $ miningServer mr
